<?php//----------------------------------------------------//recursive deletion of directory and all it's contentfunction rm_rf($dir){ $source=scandir($dir); foreach($source as $item){  if(is_file($dir.'/'.$item) && $item!=='.' && $item!=='..'){   unlink($dir.'/'.$item);  }else{}  if(is_dir($dir.'/'.$item) && $item!=='.' && $item!=='..'){   rm_rf($dir.'/'.$item);  }else{} } rmdir($dir);}//------------------------------------------------------------//get content of OSD file as arrayfunction GetODSContent($path,$fdoc){ $dirt=$path.$fdoc.'_temp'; //unzip if(is_dir($dirt)){  rm_rf($dirt); }else{} mkdir($dirt); $zip = new ZipArchive; $zip->open($path.$fdoc); $zip->extractTo($dirt); $zip->close(); //get content $fc = file($dirt.'/content.xml'); $fc_str = implode('',$fc); $fc_str_r1 = str_replace(':','__',$fc_str); $fc_str_r2 = str_replace('table-','table',$fc_str_r1); $content = simplexml_load_string($fc_str_r2); $body = $content->office__body; $sheet = $body->office__spreadsheet; $doc = array(); foreach($sheet->table__table as $table){  $tablename = $table['table__name'];  $doc["$tablename"]=array();  $nrow=0;  foreach($table->table__tablerow as $row){   $doc["$tablename"][$nrow]=array();   $ncell=0;   foreach($row->table__tablecell as $cell){    $text = $cell->text__p;    $text=trim($text);    $text=str_replace('&','&amp;',$text);    $text=str_replace('__',':',$text);    $doc["$tablename"][$nrow][$ncell] = $text;    $ncell=$ncell+1;    $rep = $cell['table__number-columns-repeated'];    if($rep>0 && $rep<5){     for($ir=0;$ir<($rep-1);$ir++){      $doc["$tablename"][$nrow][$ncell] = $text;      $ncell=$ncell+1;     }    }else{}   }    $nrow=$nrow+1;  } }  rm_rf($dirt); return($doc);}//-----------------------------------------------------------------------------//convert taxonomy to xmlfunction taxODS2xml($doc){ $xml = new SimpleXMLElement('<?xml version="1.0" encoding="UTF-8" standalone="yes"?><tree></tree>'); //make base tree and ranks array $ranks=array(); foreach($doc['ranks'] as $num=>$str){  $pstr[1]=trim($str[1]);  if($num==1){   $taxon=$str[1];   $element = $xml->addChild($taxon,'&#xA;');   $element->addChild('subtaxons','&#xA;');   $ranks[0]['taxons']=$str[0];   $ranks[0]['taxon']=$str[1];   $ranks[0]['pseudonym']=$str[2];  }else{}  //  if($num>1 && $str[0]!==''){   $ranks[($num-1)]['taxons']=$str[0];   $ranks[($num-1)]['taxon']=$str[1];   $ranks[($num-1)]['pseudonym']=$str[2];  }else{} } //add index to tree $doc['index']=array_reverse($doc['index']); foreach($doc['index'] as $num=>$str){  if(isset($str[0]) && $str[0]!==''){   $xml->addChild($str[0],$str[1]);  }else{} } //add content items to tree and make content array $contents=array(); $content_tree = $xml->addChild('content','&#xA;'); foreach($doc['content'] as $num=>$str){  $content_tree->addChild($str[0],$str[1]);  $contents['content'][$num]=$str[0]; } //add children of content to tree and to content array foreach($doc as $tab_name=>$tab){  $is_content=substr_count($tab_name,'content ');  if($is_content==1){   $child_name=str_replace('content ','',$tab_name);   $content_child = $content_tree->addChild($child_name,'&#xA;');   foreach($tab as $num=>$str){    $content_child->addChild($str[0],$str[1]);    $contents[$child_name][$num]=$str[0];   }  }else{} } //add to tree content of root taxon $root_taxon = $xml->children(); $root_rank=$ranks[0]['taxon']; foreach($doc["$root_rank"] as $num=>$str){  foreach($contents as $part=>$list){   if($part=='content'){    foreach($list as $list_num=>$val){     if(isset($str[$list_num])){      $str[$list_num]=trim($str[$list_num]);      if($num>0 && $str[$list_num]!==''){       $root_taxon->addChild($val,$str[$list_num]);      }else{}     }else{}     }   }else{    $doc["$root_rank $part"][1][1]=trim($doc["$root_rank $part"][1][1]);    if($doc["$root_rank $part"][1][1]!==''){     $root_taxon_add = $root_taxon->addChild($part,'&#xA;');     foreach($doc["$root_rank $part"] as $num=>$str){      foreach($list as $list_num=>$val){       $str[$list_num]=trim($str[$list_num]);       if($num>0 && $str[$list_num]!==''){        $root_taxon_add->addChild($val,$str[$list_num]);       }else{}      }     }    }else{}   }  } } //add to tree content of taxons foreach($ranks as $level=>$rank){  if($level!==0){   $rank_taxons=$rank['taxons'];   foreach($doc["$rank_taxons"] as $num=>$str){    $nstr=count($str);    for($i=0;$i<$nstr;$i++){     $str[$i]=str_replace('&','&amp;',$str[$i]);//trim each value in cells of the row     $str[$i]=trim($str[$i]);    }    //replace & by entity    foreach($contents as $cont_type=>$item){     if($cont_type=='content' && $str[1]!=='parent'){      @$rtaxon_ar = $xml->xpath("//$str[0][name='$str[1]']");      $rtaxon=$rtaxon_ar[0];      if($rtaxon->subtaxons){       $stx = $rtaxon->subtaxons;       if($stx->$rank['taxons']){        $stx_txs = $stx->$rank['taxons'];        $ctax = $stx_txs->addChild($rank['taxon'],'&#xA;');        $ctax->addChild('subtaxons','&#xA;');       }else{        $stx_txs = $stx->addChild($rank['taxons'],'&#xA;');        $ctax = $stx_txs->addChild($rank['taxon'],'&#xA;');        $ctax->addChild('subtaxons','&#xA;');       }      }else{}      foreach($item as $key=>$val){       if(isset($str[($key+2)])){        if($str[($key+2)]!=='' && $str[($key+2)]!==null){         $ctax->addChild($val,$str[($key+2)]);        }else{}       }else{}      }     }else{}    }   }  }else{} }  //add synonyms and may be some others  foreach($ranks as $level=>$rank){  if($level!==0){   $rank_taxons=$rank['taxons'];    foreach($contents as $cont_type=>$item){    if($cont_type!=='content'){     $rank_taxons_add=$rank_taxons.' '.$cont_type;     $empt_req=trim($doc["$rank_taxons_add"][1][1]);     if($empt_req!=="" && $empt_req!==null){//if sheet is not empty      foreach($doc["$rank_taxons_add"] as $num=>$str){        $nstr=count($str);        for($i=0;$i<$nstr;$i++){$str[$i]=str_replace('&','&amp;',$str[$i]);//trim each value in cells of the row         $str[$i]=trim($str[$i]);}//replace & by entity         if($str[1]!=='name' && $str[1]!==null){          $where=trim($rank['taxon']);          $scht_ar = $xml->xpath("..//$where");          foreach($scht_ar as $scht){           $scht_name=$scht->name;           if($scht_name==$str[0]){            $cont_dir = $scht->addChild($cont_type,'&#xA;');            foreach($item as $key=>$val){             if($str[($key+1)]!=='' && $str[($key+1)]!==null){              $cont_dir->addChild($val,$str[($key+1)]);             }else{}            }          }else{}         }        }else{}       }      }else{}     }else{}    }   }else{}  } //add pseudonyms to the groups of taxons foreach($ranks as $level=>$rank){  if($level!==0){   $sitem=trim($rank['taxons']);   $targets = $xml->xpath("..//$sitem");   foreach($targets as $target){    $target->addChild('pseudonym',$rank['pseudonym']);    $target->addChild('rank',$rank['taxon']);   }  }else{} } //add ranks schema to tree $r_tree = $xml->addChild('ranks','&#xA;'); foreach($ranks as $level=>$rank){  $r_node = $r_tree->addChild('rank','&#xA;');  $r_node->addChild('taxons',$rank['taxons']);  $r_node->addChild('taxon',$rank['taxon']);  $r_node->addChild('pseudonym',$rank['pseudonym']); } return($xml);}//----------------------------------------------------------------------------------------//get names from xml taxonomyfunction GetXMLNames($tax){ $taxrank = $tax->rank; $root_taxon = trim($taxrank); //get names from root taxon $path_text=$root_taxon.'//name'; $names_xp = $tax->xpath($path_text); $names=array(); foreach($names_xp as $no=>$name){  $names["$name"]=$no; } ksort($names); return($names);}//-----------------------------------------------------------------------------------------//convert geodata to xmlfunction geoODS2xml($doc){ $xml = new SimpleXMLElement('<?xml version="1.0" encoding="UTF-8" standalone="yes"?><geodata></geodata>'); //add locations $loc_h=get_head($doc['location'][0]); foreach($doc['location'] as $nr=>$row){  if($nr>0 && $row[0]!==''){   $location = $xml->addChild('location','&#xA;');   foreach($loc_h as $key=>$val){    if($row[$key]!==''){     $location->addChild($val,$row[$key]);    }else{}   }  }else{} } //add placemarks $pl_h=get_head($doc['placemark'][0]); foreach($pl_h as $key=>$val){  if($val=='location'){   $par_col=$key;  }else{} } foreach($doc['placemark'] as $nr=>$row){  if($nr>0 && $row[0]!==''){   $loc=$row[$par_col];   $loc_arr = $xml->xpath("//location[location='$loc']");   $location=$loc_arr[0];   if($location!==NULL){   $placemark = $location->addChild('placemark','&#xA;');   foreach($pl_h as $key=>$val){    if($row[$key]!=='' && $key!==$par_col){     $placemark->addChild($val,$row[$key]);    }else{}   }   }else{}  }else{} } return($xml);}//-----------------------------------------------------------------------------------//get headers of ODS table converted to array by function GetODSContent (see above)function get_head($arr){ $headers=array(); foreach($arr as $key=>$val){  if($val!==''){   $headers[$key]=$val;  }else{} } return($headers);}//-----------------------------------------------------------------------------------//get content of ODBC source as arrayfunction GetColl_ODBC_Content($src,$user,$pass){ $doc = array(); $tables=array('series'=>7,'specimen'=>9,'determ'=>5); $headers=array('series'=>array('series','location','cmode','habitat','datetime_start','datetime_end','collector'),                'specimen'=>array('specimen','series','taxon','nall','nmale','nfemale','nlarv','nwork','collection'),                'determ'=>array('determ','specimen','taxon','datetime','determinator')); $acc_conn=odbc_connect($src,$user,$pass); foreach($tables as $table=>$ncolumn){  $query="SELECT * FROM [".$table."]";  $res_tab=odbc_exec($acc_conn,$query);  $nrows=xodbc_num_rows($res_tab, $CurrRow = 0);  $result_tab=array();  $result_tab[0]=$headers["$table"];  for($i=0;$i<$nrows;$i++){   $result_tab[]=xodbc_fetch_array($res_tab,$i,$ncolumn);  }  $doc["$table"]=$result_tab;  @odbc_free_result($res_tab); } foreach($doc['specimen'] as $nr_sp=>$spec){  if($nr_sp>0){   for($i=3;$i<7;$i++){    $doc['specimen'][$nr_sp][$i]=round($spec[$i]);   }  }else{} } return($doc);}//---------------------------------------------------------------------------------//functions to parse result of query to ODBCfunction xodbc_num_rows($sql_id, $CurrRow = 0) {  $NumRecords = 0;  odbc_fetch_row($sql_id, 0);  while (odbc_fetch_row($sql_id))  {   $NumRecords++;  }  odbc_fetch_row($sql_id, $CurrRow);  return $NumRecords; }function xodbc_fetch_array($result,$rownumber,$limit) { odbc_fetch_into($result, &$rs, $rownumber); $lim=0; foreach ($rs as $key => $value) {   if($lim<$limit){    $rs_assoc[$key] = trim(iconv("cp1251", "UTF-8",$value));$lim++;   }else{} } return $rs_assoc;}//-----------------------------------------------------------------------------------------//convert collection data (array converted from ODS or ODCB) to xmlfunction collODS2xml($doc){ $xml = new SimpleXMLElement('<?xml version="1.0" encoding="UTF-8" standalone="yes"?><collection></collection>'); //add series $ser_h=get_head($doc['series'][0]); foreach($doc['series'] as $nr=>$row){  if($nr>0 && $row[0]!==''){   $series = $xml->addChild('series','&#xA;');   foreach($ser_h as $key=>$val){    if($row[$key]!==''){     $series->addChild($val,$row[$key]);    }else{}   }  }else{} } //add specimens $spec_h=get_head($doc['specimen'][0]); foreach($spec_h as $key=>$val){  if($val=='series'){   $par_col=$key;  }else{} } foreach($doc['specimen'] as $nr=>$row){  if($nr>0 && $row[0]!==''){   $ser=$row[$par_col];   $ser_arr = $xml->xpath("//series[series='$ser']");   if(isset($ser_arr[0])){    $series=$ser_arr[0];    $specimen = $series->addChild('specimen','&#xA;');    foreach($spec_h as $key=>$val){     if($row[$key]!=='' && $key!==$par_col){      $row[$key]=trim($row[$key]);      if($row[$key]!=='0' && $row[$key]!==0){        $specimen->addChild($val,$row[$key]);      }else{}     }else{}    }   }else{}  }else{} }  //add determs $det_h=get_head($doc['determ'][0]); foreach($det_h as $key=>$val){  if($val=='specimen'){   $par_col=$key;  }else{} } foreach($doc['determ'] as $nr=>$row){  if($nr>0 && $row[0]!==''){   $spec=$row[$par_col];   $spec_arr = $xml->xpath("//specimen[specimen='$spec']");   if(isset($spec_arr[0])){    $specimen=$spec_arr[0];    $determ = $specimen->addChild('determ','&#xA;');    foreach($det_h as $key=>$val){     if($row[$key]!=='' && $key!==$par_col){      $determ->addChild($val,$row[$key]);     }else{}    }   }else{}  }else{} } return($xml);}//-----------------------------------------------------------------------------------------//extract collection data and geodata according array of names//!: $coll_src & $geo_src - xml trees (SimlpeXMLElement objects) with all data of corresponding collection//!!!: result - array with 2 xml trees - empty or not//$control=0 - no notice about non included specimens, other - show noticesfunction ExtCollGeoByTax($result,$names,$coll_src,$geo_src,$control=0){ $coll=array(); $geo=array(); foreach($coll_src->series as $series){  $loc = $series->location;  $ser = $series->series;  foreach($series->specimen as $specimen){   $spname = $specimen->taxon;   if(isset($names["$spname"])){    if(!isset($geo["$loc"])){     $geo["$loc"]=array();    }else{}    if(!isset($coll["$ser"])){     $coll["$ser"]=array();     $coll["$ser"]["data"]=array();     $location=$series->location;$coll["$ser"]["data"]["location"]=trim($location);     $cmode=$series->cmode;$coll["$ser"]["data"]["cmode"]=trim($cmode);     $habitat=$series->habitat;$coll["$ser"]["data"]["habitat"]=trim($habitat);     $datetime_start=$series->datetime_start;$coll["$ser"]["data"]["datetime_start"]=trim($datetime_start);     $datetime_end=$series->datetime_end;$coll["$ser"]["data"]["datetime_end"]=trim($datetime_end);     $collector=$series->collector;$coll["$ser"]["data"]["collector"]=trim($collector);    }else{}    $spec=$specimen->specimen;    $coll["$ser"]["$spec"]=array();    $coll["$ser"]["$spec"]["data"]=array();    $coll["$ser"]["$spec"]["data"]["taxon"]=trim($spname);    $nall=$specimen->nall;$coll["$ser"]["$spec"]["data"]["nall"]=trim($nall);    $nmale=$specimen->nmale;$coll["$ser"]["$spec"]["data"]["nmale"]=trim($nmale);    $nfemale=$specimen->nfemale;$coll["$ser"]["$spec"]["data"]["nfemale"]=trim($nfemale);    $nlarv=$specimen->nlarv;$coll["$ser"]["$spec"]["data"]["nlarv"]=trim($nlarv);    $nwork=$specimen->nwork;$coll["$ser"]["$spec"]["data"]["nwork"]=trim($nwork);    $collection=$specimen->collection;$coll["$ser"]["$spec"]["data"]["collection"]=trim($collection);    foreach($specimen->determ as $determ){     $det=$determ->determ;     $coll["$ser"]["$spec"]["$det"]=array();     $dtname=$determ->taxon;$coll["$ser"]["$spec"]["$det"]["taxon"]=trim($dtname);     $datetime=$determ->datetime;$coll["$ser"]["$spec"]["$det"]["datetime"]=trim($datetime);     $determinator=$determ->determinator;$coll["$ser"]["$spec"]["$det"]["determinator"]=trim($determinator);    }    //   }else{    $spec=$specimen->specimen;    if($control>0){     print('Таксон '.$spname.' (№ '.$spec.') не найден в таксономии!<br>');    }else{}   }  } } //make&load xml with collection data $coll_res = $result['coll']; foreach($coll as $snum=>$ser){  $series = $coll_res->addChild('series','&#xA;');  $series->addChild('series',$snum);  foreach($ser["data"] as $key=>$val){    if($val!==''){     $series->addChild($key,$val);    }else{}  }  foreach($ser as $item1=>$data1){   if($item1!=='data'){    $spec = $series->addChild('specimen','&#xA;');    $spec->addChild('specimen',$item1);    foreach($data1["data"] as $key=>$val){     if($val!==''){      $spec->addChild($key,$val);     }else{}    }    foreach($data1 as $item2=>$data2){     if($item2!=='data'){      $det = $spec->addChild('determ','&#xA;');      $det->addChild('determ',$item2);      foreach($data2 as $key=>$val){        if($val!==''){         $det->addChild($key,$val);        }else{}      }     }else{}    }   }else{}  } } //make&load xml with geodata //make foreach($geo as $key=>$val){  $loc_arr = $geo_src->xpath("//location[location='$key']");$loc=$loc_arr[0];  $geo["$key"]["data"]=array();  $description=$loc->description;$geo["$key"]["data"]["description"]=trim($description);  $hierarhy=$loc->hierarhy;$geo["$key"]["data"]["hierarhy"]=trim($hierarhy);  $source=$loc->source;$geo["$key"]["data"]["source"]=trim($source);  $author=$loc->author;$geo["$key"]["data"]["author"]=trim($author);  foreach($loc->placemark as $placemark){   $pl_no = $placemark->placemark;   $geo["$key"]["$pl_no"]=array();   $type=$placemark->type;$geo["$key"]["$pl_no"]["type"]=trim($type);   $coordinates=$placemark->coordinates;$geo["$key"]["$pl_no"]["coordinates"]=trim($coordinates);  } } //load $geo_res = $result['geo']; foreach($geo as $lnum=>$loc){  $location = $geo_res->addChild('location','&#xA;');  $location->addChild('location',$lnum);  foreach($loc["data"] as $key=>$val){   if($val!==''){    $location->addChild($key,$val);   }else{}  }  foreach($loc as $item1=>$data1){   if($item1!=='data'){    $placemark = $location->addChild('placemark','&#xA;');    $placemark->addChild('placemark',$item1);    foreach($data1 as $key=>$val){      if($val!==''){       $placemark->addChild($key,$val);      }else{}    }   }else{}  } } $result['coll']=$coll_res; $result['geo']=$geo_res; return($result);}//-----------------------------------------------------------------------------------------//create zip archive with the content of directory (non recursively!)function ZipDir($path,$dir){ $zip=new ZipArchive; $zip->open($path.'/'.$dir.'/'.$dir.'.zip', ZipArchive::CREATE); $content=scandir($path.'/'.$dir); foreach($content as $n=>$item){  if($item!=='.' && $item!=='..' && !is_dir($path.'/'.$dir.'/'.$item)){   $zip->addFile($path.'/'.$dir.'/'.$item,$item);  }else{} } $zip->close();}//-----------------------------------------------------------------------------------------//create xml tree of collections from some full xml tree of collections and actual collections treefunction MakeCollIndex($all_colls,$coll_tree){ $all_collections=array(); $allc_xml = simplexml_load_file($all_colls); foreach($allc_xml->collection as $collection){  $name=$collection->name;  $name=trim($name);  $all_collections["$name"]=array();  $description=$collection->description;  $owner=$collection->owner;  $curator=$collection->curator;  $contact=$collection->contact;  $all_collections["$name"]['description']=trim($description);  $all_collections["$name"]['owner']=trim($owner);  $all_collections["$name"]['curator']=trim($curator);  $all_collections["$name"]['contact']=trim($contact); } $real_collections=array(); $realc_xml_arr=$coll_tree->xpath("//collection"); foreach($realc_xml_arr as $realc){  $rc_name=trim($realc);  if(isset($all_collections["$rc_name"]) && !isset($real_collections["$rc_name"])){   $real_collections["$rc_name"]=$all_collections["$rc_name"];  }else{} } $collections=new SimpleXMLElement('<?xml version="1.0" encoding="UTF-8" standalone="yes"?><collections></collections>'); foreach($real_collections as $cname=>$ccont){  $collection=$collections->addChild('collection','&#xA;');  $collection->addChild('name',$cname);  foreach($ccont as $key=>$val){   $collection->addChild($key,$val);  } } return($collections);}?>